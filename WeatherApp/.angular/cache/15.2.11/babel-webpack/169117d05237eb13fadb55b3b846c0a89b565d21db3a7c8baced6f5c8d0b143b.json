{
  "ast": null,
  "code": "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\nimport { defaultConverter, notEqual } from '../reactive-element.js';\nconst DEV_MODE = true;\nlet issueWarning;\nif (DEV_MODE) {\n  // Ensure warnings are issued only 1x, even if multiple versions of Lit\n  // are loaded.\n  const issuedWarnings = globalThis.litIssuedWarnings ??= new Set();\n  // Issue a warning, if we haven't already.\n  issueWarning = (code, warning) => {\n    warning += ` See https://lit.dev/msg/${code} for more information.`;\n    if (!issuedWarnings.has(warning)) {\n      console.warn(warning);\n      issuedWarnings.add(warning);\n    }\n  };\n}\nconst legacyProperty = (options, proto, name) => {\n  const hasOwnProperty = proto.hasOwnProperty(name);\n  proto.constructor.createProperty(name, hasOwnProperty ? {\n    ...options,\n    wrapped: true\n  } : options);\n  // For accessors (which have a descriptor on the prototype) we need to\n  // return a descriptor, otherwise TypeScript overwrites the descriptor we\n  // define in createProperty() with the original descriptor. We don't do this\n  // for fields, which don't have a descriptor, because this could overwrite\n  // descriptor defined by other decorators.\n  return hasOwnProperty ? Object.getOwnPropertyDescriptor(proto, name) : undefined;\n};\n// This is duplicated from a similar variable in reactive-element.ts, but\n// actually makes sense to have this default defined with the decorator, so\n// that different decorators could have different defaults.\nconst defaultPropertyDeclaration = {\n  attribute: true,\n  type: String,\n  converter: defaultConverter,\n  reflect: false,\n  hasChanged: notEqual\n};\n/**\n * Wraps a class accessor or setter so that `requestUpdate()` is called with the\n * property name and old value when the accessor is set.\n */\nexport const standardProperty = (options = defaultPropertyDeclaration, target, context) => {\n  const {\n    kind,\n    metadata\n  } = context;\n  if (DEV_MODE && metadata == null) {\n    issueWarning('missing-class-metadata', `The class ${target} is missing decorator metadata. This ` + `could mean that you're using a compiler that supports decorators ` + `but doesn't support decorator metadata, such as TypeScript 5.1. ` + `Please update your compiler.`);\n  }\n  // Store the property options\n  let properties = globalThis.litPropertyMetadata.get(metadata);\n  if (properties === undefined) {\n    globalThis.litPropertyMetadata.set(metadata, properties = new Map());\n  }\n  properties.set(context.name, options);\n  if (kind === 'accessor') {\n    // Standard decorators cannot dynamically modify the class, so we can't\n    // replace a field with accessors. The user must use the new `accessor`\n    // keyword instead.\n    const {\n      name\n    } = context;\n    return {\n      set(v) {\n        const oldValue = target.get.call(this);\n        target.set.call(this, v);\n        this.requestUpdate(name, oldValue, options);\n      },\n      init(v) {\n        if (v !== undefined) {\n          this._$changeProperty(name, undefined, options);\n        }\n        return v;\n      }\n    };\n  } else if (kind === 'setter') {\n    const {\n      name\n    } = context;\n    return function (value) {\n      const oldValue = this[name];\n      target.call(this, value);\n      this.requestUpdate(name, oldValue, options);\n    };\n  }\n  throw new Error(`Unsupported decorator location: ${kind}`);\n};\n/**\n * A class field or accessor decorator which creates a reactive property that\n * reflects a corresponding attribute value. When a decorated property is set\n * the element will update and render. A {@linkcode PropertyDeclaration} may\n * optionally be supplied to configure property features.\n *\n * This decorator should only be used for public fields. As public fields,\n * properties should be considered as primarily settable by element users,\n * either via attribute or the property itself.\n *\n * Generally, properties that are changed by the element should be private or\n * protected fields and should use the {@linkcode state} decorator.\n *\n * However, sometimes element code does need to set a public property. This\n * should typically only be done in response to user interaction, and an event\n * should be fired informing the user; for example, a checkbox sets its\n * `checked` property when clicked and fires a `changed` event. Mutating public\n * properties should typically not be done for non-primitive (object or array)\n * properties. In other cases when an element needs to manage state, a private\n * property decorated via the {@linkcode state} decorator should be used. When\n * needed, state properties can be initialized via public properties to\n * facilitate complex interactions.\n *\n * ```ts\n * class MyElement {\n *   @property({ type: Boolean })\n *   clicked = false;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\nexport function property(options) {\n  return (protoOrTarget, nameOrContext\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ) => {\n    return typeof nameOrContext === 'object' ? standardProperty(options, protoOrTarget, nameOrContext) : legacyProperty(options, protoOrTarget, nameOrContext);\n  };\n}",
  "map": {
    "version": 3,
    "names": [
      "defaultConverter",
      "notEqual",
      "DEV_MODE",
      "issueWarning",
      "issuedWarnings",
      "globalThis",
      "litIssuedWarnings",
      "Set",
      "code",
      "warning",
      "has",
      "console",
      "warn",
      "add",
      "legacyProperty",
      "options",
      "proto",
      "name",
      "hasOwnProperty",
      "constructor",
      "createProperty",
      "wrapped",
      "Object",
      "getOwnPropertyDescriptor",
      "undefined",
      "defaultPropertyDeclaration",
      "attribute",
      "type",
      "String",
      "converter",
      "reflect",
      "hasChanged",
      "standardProperty",
      "target",
      "context",
      "kind",
      "metadata",
      "properties",
      "litPropertyMetadata",
      "get",
      "set",
      "Map",
      "v",
      "oldValue",
      "call",
      "requestUpdate",
      "init",
      "_$changeProperty",
      "value",
      "Error",
      "property",
      "protoOrTarget",
      "nameOrContext"
    ],
    "sources": [
      "/home/asplap2479/Documents/Learning/weather-application/WeatherApp/node_modules/@lit/reactive-element/development/decorators/property.js"
    ],
    "sourcesContent": [
      "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/*\n * IMPORTANT: For compatibility with tsickle and the Closure JS compiler, all\n * property decorators (but not class decorators) in this file that have\n * an @ExportDecoratedItems annotation must be defined as a regular function,\n * not an arrow function.\n */\nimport { defaultConverter, notEqual, } from '../reactive-element.js';\nconst DEV_MODE = true;\nlet issueWarning;\nif (DEV_MODE) {\n    // Ensure warnings are issued only 1x, even if multiple versions of Lit\n    // are loaded.\n    const issuedWarnings = (globalThis.litIssuedWarnings ??= new Set());\n    // Issue a warning, if we haven't already.\n    issueWarning = (code, warning) => {\n        warning += ` See https://lit.dev/msg/${code} for more information.`;\n        if (!issuedWarnings.has(warning)) {\n            console.warn(warning);\n            issuedWarnings.add(warning);\n        }\n    };\n}\nconst legacyProperty = (options, proto, name) => {\n    const hasOwnProperty = proto.hasOwnProperty(name);\n    proto.constructor.createProperty(name, hasOwnProperty ? { ...options, wrapped: true } : options);\n    // For accessors (which have a descriptor on the prototype) we need to\n    // return a descriptor, otherwise TypeScript overwrites the descriptor we\n    // define in createProperty() with the original descriptor. We don't do this\n    // for fields, which don't have a descriptor, because this could overwrite\n    // descriptor defined by other decorators.\n    return hasOwnProperty\n        ? Object.getOwnPropertyDescriptor(proto, name)\n        : undefined;\n};\n// This is duplicated from a similar variable in reactive-element.ts, but\n// actually makes sense to have this default defined with the decorator, so\n// that different decorators could have different defaults.\nconst defaultPropertyDeclaration = {\n    attribute: true,\n    type: String,\n    converter: defaultConverter,\n    reflect: false,\n    hasChanged: notEqual,\n};\n/**\n * Wraps a class accessor or setter so that `requestUpdate()` is called with the\n * property name and old value when the accessor is set.\n */\nexport const standardProperty = (options = defaultPropertyDeclaration, target, context) => {\n    const { kind, metadata } = context;\n    if (DEV_MODE && metadata == null) {\n        issueWarning('missing-class-metadata', `The class ${target} is missing decorator metadata. This ` +\n            `could mean that you're using a compiler that supports decorators ` +\n            `but doesn't support decorator metadata, such as TypeScript 5.1. ` +\n            `Please update your compiler.`);\n    }\n    // Store the property options\n    let properties = globalThis.litPropertyMetadata.get(metadata);\n    if (properties === undefined) {\n        globalThis.litPropertyMetadata.set(metadata, (properties = new Map()));\n    }\n    properties.set(context.name, options);\n    if (kind === 'accessor') {\n        // Standard decorators cannot dynamically modify the class, so we can't\n        // replace a field with accessors. The user must use the new `accessor`\n        // keyword instead.\n        const { name } = context;\n        return {\n            set(v) {\n                const oldValue = target.get.call(this);\n                target.set.call(this, v);\n                this.requestUpdate(name, oldValue, options);\n            },\n            init(v) {\n                if (v !== undefined) {\n                    this._$changeProperty(name, undefined, options);\n                }\n                return v;\n            },\n        };\n    }\n    else if (kind === 'setter') {\n        const { name } = context;\n        return function (value) {\n            const oldValue = this[name];\n            target.call(this, value);\n            this.requestUpdate(name, oldValue, options);\n        };\n    }\n    throw new Error(`Unsupported decorator location: ${kind}`);\n};\n/**\n * A class field or accessor decorator which creates a reactive property that\n * reflects a corresponding attribute value. When a decorated property is set\n * the element will update and render. A {@linkcode PropertyDeclaration} may\n * optionally be supplied to configure property features.\n *\n * This decorator should only be used for public fields. As public fields,\n * properties should be considered as primarily settable by element users,\n * either via attribute or the property itself.\n *\n * Generally, properties that are changed by the element should be private or\n * protected fields and should use the {@linkcode state} decorator.\n *\n * However, sometimes element code does need to set a public property. This\n * should typically only be done in response to user interaction, and an event\n * should be fired informing the user; for example, a checkbox sets its\n * `checked` property when clicked and fires a `changed` event. Mutating public\n * properties should typically not be done for non-primitive (object or array)\n * properties. In other cases when an element needs to manage state, a private\n * property decorated via the {@linkcode state} decorator should be used. When\n * needed, state properties can be initialized via public properties to\n * facilitate complex interactions.\n *\n * ```ts\n * class MyElement {\n *   @property({ type: Boolean })\n *   clicked = false;\n * }\n * ```\n * @category Decorator\n * @ExportDecoratedItems\n */\nexport function property(options) {\n    return (protoOrTarget, nameOrContext\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    ) => {\n        return (typeof nameOrContext === 'object'\n            ? standardProperty(options, protoOrTarget, nameOrContext)\n            : legacyProperty(options, protoOrTarget, nameOrContext));\n    };\n}\n"
    ],
    "mappings": "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",
    "ignoreList": []
  },
  "metadata": {},
  "sourceType": "module",
  "externalDependencies": []
}
