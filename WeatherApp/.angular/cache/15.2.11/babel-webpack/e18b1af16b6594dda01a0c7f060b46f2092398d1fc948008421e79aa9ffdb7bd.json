{
  "ast": null,
  "code": "import _asyncToGenerator from \"/home/asplap2479/Documents/Learning/weather-application/WeatherApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/**\n * Use this module if you want to create your own base class extending\n * {@link ReactiveElement}.\n * @packageDocumentation\n */\nimport { getCompatibleStyle, adoptStyles } from './css-tag.js';\n// In the Node build, this import will be injected by Rollup:\n// import {HTMLElement, customElements} from '@lit-labs/ssr-dom-shim';\nexport * from './css-tag.js';\n// TODO (justinfagnani): Add `hasOwn` here when we ship ES2022\nconst {\n  is,\n  defineProperty,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getOwnPropertySymbols,\n  getPrototypeOf\n} = Object;\nconst NODE_MODE = false;\n// Lets a minifier replace globalThis references with a minified name\nconst global = globalThis;\nif (NODE_MODE) {\n  global.customElements ??= customElements;\n}\nconst DEV_MODE = true;\nlet issueWarning;\nconst trustedTypes = global.trustedTypes;\n// Temporary workaround for https://crbug.com/993268\n// Currently, any attribute starting with \"on\" is considered to be a\n// TrustedScript source. Such boolean attributes must be set to the equivalent\n// trusted emptyScript value.\nconst emptyStringForBooleanAttribute = trustedTypes ? trustedTypes.emptyScript : '';\nconst polyfillSupport = DEV_MODE ? global.reactiveElementPolyfillSupportDevMode : global.reactiveElementPolyfillSupport;\nif (DEV_MODE) {\n  // Ensure warnings are issued only 1x, even if multiple versions of Lit\n  // are loaded.\n  const issuedWarnings = global.litIssuedWarnings ??= new Set();\n  // Issue a warning, if we haven't already.\n  issueWarning = (code, warning) => {\n    warning += ` See https://lit.dev/msg/${code} for more information.`;\n    if (!issuedWarnings.has(warning)) {\n      console.warn(warning);\n      issuedWarnings.add(warning);\n    }\n  };\n  issueWarning('dev-mode', `Lit is in dev mode. Not recommended for production!`);\n  // Issue polyfill support warning.\n  if (global.ShadyDOM?.inUse && polyfillSupport === undefined) {\n    issueWarning('polyfill-support-missing', `Shadow DOM is being polyfilled via \\`ShadyDOM\\` but ` + `the \\`polyfill-support\\` module has not been loaded.`);\n  }\n}\n/**\n * Useful for visualizing and logging insights into what the Lit template system is doing.\n *\n * Compiled out of prod mode builds.\n */\nconst debugLogEvent = DEV_MODE ? event => {\n  const shouldEmit = global.emitLitDebugLogEvents;\n  if (!shouldEmit) {\n    return;\n  }\n  global.dispatchEvent(new CustomEvent('lit-debug', {\n    detail: event\n  }));\n} : undefined;\n/*\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */\n/*@__INLINE__*/\nconst JSCompiler_renameProperty = (prop, _obj) => prop;\nexport const defaultConverter = {\n  toAttribute(value, type) {\n    switch (type) {\n      case Boolean:\n        value = value ? emptyStringForBooleanAttribute : null;\n        break;\n      case Object:\n      case Array:\n        // if the value is `null` or `undefined` pass this through\n        // to allow removing/no change behavior.\n        value = value == null ? value : JSON.stringify(value);\n        break;\n    }\n    return value;\n  },\n  fromAttribute(value, type) {\n    let fromValue = value;\n    switch (type) {\n      case Boolean:\n        fromValue = value !== null;\n        break;\n      case Number:\n        fromValue = value === null ? null : Number(value);\n        break;\n      case Object:\n      case Array:\n        // Do *not* generate exception when invalid JSON is set as elements\n        // don't normally complain on being mis-configured.\n        // TODO(sorvell): Do generate exception in *dev mode*.\n        try {\n          // Assert to adhere to Bazel's \"must type assert JSON parse\" rule.\n          fromValue = JSON.parse(value);\n        } catch (e) {\n          fromValue = null;\n        }\n        break;\n    }\n    return fromValue;\n  }\n};\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property's `hasChanged` function.\n */\nexport const notEqual = (value, old) => !is(value, old);\nconst defaultPropertyDeclaration = {\n  attribute: true,\n  type: String,\n  converter: defaultConverter,\n  reflect: false,\n  hasChanged: notEqual\n};\n// Ensure metadata is enabled. TypeScript does not polyfill\n// Symbol.metadata, so we must ensure that it exists.\nSymbol.metadata ??= Symbol('metadata');\n// Map from a class's metadata object to property options\n// Note that we must use nullish-coalescing assignment so that we only use one\n// map even if we load multiple version of this module.\nglobal.litPropertyMetadata ??= new WeakMap();\n/**\n * Base element class which manages element properties and attributes. When\n * properties change, the `update` method is asynchronously called. This method\n * should be supplied by subclasses to render updates as desired.\n * @noInheritDoc\n */\nexport class ReactiveElement\n// In the Node build, this `extends` clause will be substituted with\n// `(globalThis.HTMLElement ?? HTMLElement)`.\n//\n// This way, we will first prefer any global `HTMLElement` polyfill that the\n// user has assigned, and then fall back to the `HTMLElement` shim which has\n// been imported (see note at the top of this file about how this import is\n// generated by Rollup). Note that the `HTMLElement` variable has been\n// shadowed by this import, so it no longer refers to the global.\nextends HTMLElement {\n  /**\n   * Adds an initializer function to the class that is called during instance\n   * construction.\n   *\n   * This is useful for code that runs against a `ReactiveElement`\n   * subclass, such as a decorator, that needs to do work for each\n   * instance, such as setting up a `ReactiveController`.\n   *\n   * ```ts\n   * const myDecorator = (target: typeof ReactiveElement, key: string) => {\n   *   target.addInitializer((instance: ReactiveElement) => {\n   *     // This is run during construction of the element\n   *     new MyController(instance);\n   *   });\n   * }\n   * ```\n   *\n   * Decorating a field will then cause each instance to run an initializer\n   * that adds a controller:\n   *\n   * ```ts\n   * class MyElement extends LitElement {\n   *   @myDecorator foo;\n   * }\n   * ```\n   *\n   * Initializers are stored per-constructor. Adding an initializer to a\n   * subclass does not add it to a superclass. Since initializers are run in\n   * constructors, initializers will run in order of the class hierarchy,\n   * starting with superclasses and progressing to the instance's class.\n   *\n   * @nocollapse\n   */\n  static addInitializer(initializer) {\n    this.__prepare();\n    (this._initializers ??= []).push(initializer);\n  }\n  /**\n   * Returns a list of attributes corresponding to the registered properties.\n   * @nocollapse\n   * @category attributes\n   */\n  static get observedAttributes() {\n    // Ensure we've created all properties\n    this.finalize();\n    // this.__attributeToPropertyMap is only undefined after finalize() in\n    // ReactiveElement itself. ReactiveElement.observedAttributes is only\n    // accessed with ReactiveElement as the receiver when a subclass or mixin\n    // calls super.observedAttributes\n    return this.__attributeToPropertyMap && [...this.__attributeToPropertyMap.keys()];\n  }\n  /**\n   * Creates a property accessor on the element prototype if one does not exist\n   * and stores a {@linkcode PropertyDeclaration} for the property with the\n   * given options. The property setter calls the property's `hasChanged`\n   * property option or uses a strict identity check to determine whether or not\n   * to request an update.\n   *\n   * This method may be overridden to customize properties; however,\n   * when doing so, it's important to call `super.createProperty` to ensure\n   * the property is setup correctly. This method calls\n   * `getPropertyDescriptor` internally to get a descriptor to install.\n   * To customize what properties do when they are get or set, override\n   * `getPropertyDescriptor`. To customize the options for a property,\n   * implement `createProperty` like this:\n   *\n   * ```ts\n   * static createProperty(name, options) {\n   *   options = Object.assign(options, {myOption: true});\n   *   super.createProperty(name, options);\n   * }\n   * ```\n   *\n   * @nocollapse\n   * @category properties\n   */\n  static createProperty(name, options = defaultPropertyDeclaration) {\n    // If this is a state property, force the attribute to false.\n    if (options.state) {\n      options.attribute = false;\n    }\n    this.__prepare();\n    this.elementProperties.set(name, options);\n    if (!options.noAccessor) {\n      const key = DEV_MODE ?\n      // Use Symbol.for in dev mode to make it easier to maintain state\n      // when doing HMR.\n      Symbol.for(`${String(name)} (@property() cache)`) : Symbol();\n      const descriptor = this.getPropertyDescriptor(name, key, options);\n      if (descriptor !== undefined) {\n        defineProperty(this.prototype, name, descriptor);\n      }\n    }\n  }\n  /**\n   * Returns a property descriptor to be defined on the given named property.\n   * If no descriptor is returned, the property will not become an accessor.\n   * For example,\n   *\n   * ```ts\n   * class MyElement extends LitElement {\n   *   static getPropertyDescriptor(name, key, options) {\n   *     const defaultDescriptor =\n   *         super.getPropertyDescriptor(name, key, options);\n   *     const setter = defaultDescriptor.set;\n   *     return {\n   *       get: defaultDescriptor.get,\n   *       set(value) {\n   *         setter.call(this, value);\n   *         // custom action.\n   *       },\n   *       configurable: true,\n   *       enumerable: true\n   *     }\n   *   }\n   * }\n   * ```\n   *\n   * @nocollapse\n   * @category properties\n   */\n  static getPropertyDescriptor(name, key, options) {\n    const {\n      get,\n      set\n    } = getOwnPropertyDescriptor(this.prototype, name) ?? {\n      get() {\n        return this[key];\n      },\n      set(v) {\n        this[key] = v;\n      }\n    };\n    if (DEV_MODE && get == null) {\n      if ('value' in (getOwnPropertyDescriptor(this.prototype, name) ?? {})) {\n        throw new Error(`Field ${JSON.stringify(String(name))} on ` + `${this.name} was declared as a reactive property ` + `but it's actually declared as a value on the prototype. ` + `Usually this is due to using @property or @state on a method.`);\n      }\n      issueWarning('reactive-property-without-getter', `Field ${JSON.stringify(String(name))} on ` + `${this.name} was declared as a reactive property ` + `but it does not have a getter. This will be an error in a ` + `future version of Lit.`);\n    }\n    return {\n      get() {\n        return get?.call(this);\n      },\n      set(value) {\n        const oldValue = get?.call(this);\n        set.call(this, value);\n        this.requestUpdate(name, oldValue, options);\n      },\n      configurable: true,\n      enumerable: true\n    };\n  }\n  /**\n   * Returns the property options associated with the given property.\n   * These options are defined with a `PropertyDeclaration` via the `properties`\n   * object or the `@property` decorator and are registered in\n   * `createProperty(...)`.\n   *\n   * Note, this method should be considered \"final\" and not overridden. To\n   * customize the options for a given property, override\n   * {@linkcode createProperty}.\n   *\n   * @nocollapse\n   * @final\n   * @category properties\n   */\n  static getPropertyOptions(name) {\n    return this.elementProperties.get(name) ?? defaultPropertyDeclaration;\n  }\n  /**\n   * Initializes static own properties of the class used in bookkeeping\n   * for element properties, initializers, etc.\n   *\n   * Can be called multiple times by code that needs to ensure these\n   * properties exist before using them.\n   *\n   * This method ensures the superclass is finalized so that inherited\n   * property metadata can be copied down.\n   * @nocollapse\n   */\n  static __prepare() {\n    if (this.hasOwnProperty(JSCompiler_renameProperty('elementProperties', this))) {\n      // Already prepared\n      return;\n    }\n    // Finalize any superclasses\n    const superCtor = getPrototypeOf(this);\n    superCtor.finalize();\n    // Create own set of initializers for this class if any exist on the\n    // superclass and copy them down. Note, for a small perf boost, avoid\n    // creating initializers unless needed.\n    if (superCtor._initializers !== undefined) {\n      this._initializers = [...superCtor._initializers];\n    }\n    // Initialize elementProperties from the superclass\n    this.elementProperties = new Map(superCtor.elementProperties);\n  }\n  /**\n   * Finishes setting up the class so that it's ready to be registered\n   * as a custom element and instantiated.\n   *\n   * This method is called by the ReactiveElement.observedAttributes getter.\n   * If you override the observedAttributes getter, you must either call\n   * super.observedAttributes to trigger finalization, or call finalize()\n   * yourself.\n   *\n   * @nocollapse\n   */\n  static finalize() {\n    if (this.hasOwnProperty(JSCompiler_renameProperty('finalized', this))) {\n      return;\n    }\n    this.finalized = true;\n    this.__prepare();\n    // Create properties from the static properties block:\n    if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {\n      const props = this.properties;\n      const propKeys = [...getOwnPropertyNames(props), ...getOwnPropertySymbols(props)];\n      for (const p of propKeys) {\n        this.createProperty(p, props[p]);\n      }\n    }\n    // Create properties from standard decorator metadata:\n    const metadata = this[Symbol.metadata];\n    if (metadata !== null) {\n      const properties = litPropertyMetadata.get(metadata);\n      if (properties !== undefined) {\n        for (const [p, options] of properties) {\n          this.elementProperties.set(p, options);\n        }\n      }\n    }\n    // Create the attribute-to-property map\n    this.__attributeToPropertyMap = new Map();\n    for (const [p, options] of this.elementProperties) {\n      const attr = this.__attributeNameForProperty(p, options);\n      if (attr !== undefined) {\n        this.__attributeToPropertyMap.set(attr, p);\n      }\n    }\n    this.elementStyles = this.finalizeStyles(this.styles);\n    if (DEV_MODE) {\n      if (this.hasOwnProperty('createProperty')) {\n        issueWarning('no-override-create-property', 'Overriding ReactiveElement.createProperty() is deprecated. ' + 'The override will not be called with standard decorators');\n      }\n      if (this.hasOwnProperty('getPropertyDescriptor')) {\n        issueWarning('no-override-get-property-descriptor', 'Overriding ReactiveElement.getPropertyDescriptor() is deprecated. ' + 'The override will not be called with standard decorators');\n      }\n    }\n  }\n  /**\n   * Takes the styles the user supplied via the `static styles` property and\n   * returns the array of styles to apply to the element.\n   * Override this method to integrate into a style management system.\n   *\n   * Styles are deduplicated preserving the _last_ instance in the list. This\n   * is a performance optimization to avoid duplicated styles that can occur\n   * especially when composing via subclassing. The last item is kept to try\n   * to preserve the cascade order with the assumption that it's most important\n   * that last added styles override previous styles.\n   *\n   * @nocollapse\n   * @category styles\n   */\n  static finalizeStyles(styles) {\n    const elementStyles = [];\n    if (Array.isArray(styles)) {\n      // Dedupe the flattened array in reverse order to preserve the last items.\n      // Casting to Array<unknown> works around TS error that\n      // appears to come from trying to flatten a type CSSResultArray.\n      const set = new Set(styles.flat(Infinity).reverse());\n      // Then preserve original order by adding the set items in reverse order.\n      for (const s of set) {\n        elementStyles.unshift(getCompatibleStyle(s));\n      }\n    } else if (styles !== undefined) {\n      elementStyles.push(getCompatibleStyle(styles));\n    }\n    return elementStyles;\n  }\n  /**\n   * Returns the property name for the given attribute `name`.\n   * @nocollapse\n   */\n  static __attributeNameForProperty(name, options) {\n    const attribute = options.attribute;\n    return attribute === false ? undefined : typeof attribute === 'string' ? attribute : typeof name === 'string' ? name.toLowerCase() : undefined;\n  }\n  constructor() {\n    super();\n    this.__instanceProperties = undefined;\n    /**\n     * True if there is a pending update as a result of calling `requestUpdate()`.\n     * Should only be read.\n     * @category updates\n     */\n    this.isUpdatePending = false;\n    /**\n     * Is set to `true` after the first update. The element code cannot assume\n     * that `renderRoot` exists before the element `hasUpdated`.\n     * @category updates\n     */\n    this.hasUpdated = false;\n    /**\n     * Name of currently reflecting property\n     */\n    this.__reflectingProperty = null;\n    this.__initialize();\n  }\n  /**\n   * Internal only override point for customizing work done when elements\n   * are constructed.\n   */\n  __initialize() {\n    this.__updatePromise = new Promise(res => this.enableUpdating = res);\n    this._$changedProperties = new Map();\n    // This enqueues a microtask that ust run before the first update, so it\n    // must be called before requestUpdate()\n    this.__saveInstanceProperties();\n    // ensures first update will be caught by an early access of\n    // `updateComplete`\n    this.requestUpdate();\n    this.constructor._initializers?.forEach(i => i(this));\n  }\n  /**\n   * Registers a `ReactiveController` to participate in the element's reactive\n   * update cycle. The element automatically calls into any registered\n   * controllers during its lifecycle callbacks.\n   *\n   * If the element is connected when `addController()` is called, the\n   * controller's `hostConnected()` callback will be immediately called.\n   * @category controllers\n   */\n  addController(controller) {\n    (this.__controllers ??= new Set()).add(controller);\n    // If a controller is added after the element has been connected,\n    // call hostConnected. Note, re-using existence of `renderRoot` here\n    // (which is set in connectedCallback) to avoid the need to track a\n    // first connected state.\n    if (this.renderRoot !== undefined && this.isConnected) {\n      controller.hostConnected?.();\n    }\n  }\n  /**\n   * Removes a `ReactiveController` from the element.\n   * @category controllers\n   */\n  removeController(controller) {\n    this.__controllers?.delete(controller);\n  }\n  /**\n   * Fixes any properties set on the instance before upgrade time.\n   * Otherwise these would shadow the accessor and break these properties.\n   * The properties are stored in a Map which is played back after the\n   * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\n   * (<=41), properties created for native platform properties like (`id` or\n   * `name`) may not have default values set in the element constructor. On\n   * these browsers native properties appear on instances and therefore their\n   * default value will overwrite any element default (e.g. if the element sets\n   * this.id = 'id' in the constructor, the 'id' will become '' since this is\n   * the native platform default).\n   */\n  __saveInstanceProperties() {\n    const instanceProperties = new Map();\n    const elementProperties = this.constructor.elementProperties;\n    for (const p of elementProperties.keys()) {\n      if (this.hasOwnProperty(p)) {\n        instanceProperties.set(p, this[p]);\n        delete this[p];\n      }\n    }\n    if (instanceProperties.size > 0) {\n      this.__instanceProperties = instanceProperties;\n    }\n  }\n  /**\n   * Returns the node into which the element should render and by default\n   * creates and returns an open shadowRoot. Implement to customize where the\n   * element's DOM is rendered. For example, to render into the element's\n   * childNodes, return `this`.\n   *\n   * @return Returns a node into which to render.\n   * @category rendering\n   */\n  createRenderRoot() {\n    const renderRoot = this.shadowRoot ?? this.attachShadow(this.constructor.shadowRootOptions);\n    adoptStyles(renderRoot, this.constructor.elementStyles);\n    return renderRoot;\n  }\n  /**\n   * On first connection, creates the element's renderRoot, sets up\n   * element styling, and enables updating.\n   * @category lifecycle\n   */\n  connectedCallback() {\n    // Create renderRoot before controllers `hostConnected`\n    this.renderRoot ??= this.createRenderRoot();\n    this.enableUpdating(true);\n    this.__controllers?.forEach(c => c.hostConnected?.());\n  }\n  /**\n   * Note, this method should be considered final and not overridden. It is\n   * overridden on the element instance with a function that triggers the first\n   * update.\n   * @category updates\n   */\n  enableUpdating(_requestedUpdate) {}\n  /**\n   * Allows for `super.disconnectedCallback()` in extensions while\n   * reserving the possibility of making non-breaking feature additions\n   * when disconnecting at some point in the future.\n   * @category lifecycle\n   */\n  disconnectedCallback() {\n    this.__controllers?.forEach(c => c.hostDisconnected?.());\n  }\n  /**\n   * Synchronizes property values when attributes change.\n   *\n   * Specifically, when an attribute is set, the corresponding property is set.\n   * You should rarely need to implement this callback. If this method is\n   * overridden, `super.attributeChangedCallback(name, _old, value)` must be\n   * called.\n   *\n   * See [using the lifecycle callbacks](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks)\n   * on MDN for more information about the `attributeChangedCallback`.\n   * @category attributes\n   */\n  attributeChangedCallback(name, _old, value) {\n    this._$attributeToProperty(name, value);\n  }\n  __propertyToAttribute(name, value) {\n    const elemProperties = this.constructor.elementProperties;\n    const options = elemProperties.get(name);\n    const attr = this.constructor.__attributeNameForProperty(name, options);\n    if (attr !== undefined && options.reflect === true) {\n      const converter = options.converter?.toAttribute !== undefined ? options.converter : defaultConverter;\n      const attrValue = converter.toAttribute(value, options.type);\n      if (DEV_MODE && this.constructor.enabledWarnings.includes('migration') && attrValue === undefined) {\n        issueWarning('undefined-attribute-value', `The attribute value for the ${name} property is ` + `undefined on element ${this.localName}. The attribute will be ` + `removed, but in the previous version of \\`ReactiveElement\\`, ` + `the attribute would not have changed.`);\n      }\n      // Track if the property is being reflected to avoid\n      // setting the property again via `attributeChangedCallback`. Note:\n      // 1. this takes advantage of the fact that the callback is synchronous.\n      // 2. will behave incorrectly if multiple attributes are in the reaction\n      // stack at time of calling. However, since we process attributes\n      // in `update` this should not be possible (or an extreme corner case\n      // that we'd like to discover).\n      // mark state reflecting\n      this.__reflectingProperty = name;\n      if (attrValue == null) {\n        this.removeAttribute(attr);\n      } else {\n        this.setAttribute(attr, attrValue);\n      }\n      // mark state not reflecting\n      this.__reflectingProperty = null;\n    }\n  }\n  /** @internal */\n  _$attributeToProperty(name, value) {\n    const ctor = this.constructor;\n    // Note, hint this as an `AttributeMap` so closure clearly understands\n    // the type; it has issues with tracking types through statics\n    const propName = ctor.__attributeToPropertyMap.get(name);\n    // Use tracking info to avoid reflecting a property value to an attribute\n    // if it was just set because the attribute changed.\n    if (propName !== undefined && this.__reflectingProperty !== propName) {\n      const options = ctor.getPropertyOptions(propName);\n      const converter = typeof options.converter === 'function' ? {\n        fromAttribute: options.converter\n      } : options.converter?.fromAttribute !== undefined ? options.converter : defaultConverter;\n      // mark state reflecting\n      this.__reflectingProperty = propName;\n      this[propName] = converter.fromAttribute(value, options.type\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      );\n      // mark state not reflecting\n      this.__reflectingProperty = null;\n    }\n  }\n  /**\n   * Requests an update which is processed asynchronously. This should be called\n   * when an element should update based on some state not triggered by setting\n   * a reactive property. In this case, pass no arguments. It should also be\n   * called when manually implementing a property setter. In this case, pass the\n   * property `name` and `oldValue` to ensure that any configured property\n   * options are honored.\n   *\n   * @param name name of requesting property\n   * @param oldValue old value of requesting property\n   * @param options property options to use instead of the previously\n   *     configured options\n   * @category updates\n   */\n  requestUpdate(name, oldValue, options) {\n    // If we have a property key, perform property update steps.\n    if (name !== undefined) {\n      if (DEV_MODE && name instanceof Event) {\n        issueWarning(``, `The requestUpdate() method was called with an Event as the property name. This is probably a mistake caused by binding this.requestUpdate as an event listener. Instead bind a function that will call it with no arguments: () => this.requestUpdate()`);\n      }\n      options ??= this.constructor.getPropertyOptions(name);\n      const hasChanged = options.hasChanged ?? notEqual;\n      const newValue = this[name];\n      if (hasChanged(newValue, oldValue)) {\n        this._$changeProperty(name, oldValue, options);\n      } else {\n        // Abort the request if the property should not be considered changed.\n        return;\n      }\n    }\n    if (this.isUpdatePending === false) {\n      this.__updatePromise = this.__enqueueUpdate();\n    }\n  }\n  /**\n   * @internal\n   */\n  _$changeProperty(name, oldValue, options) {\n    // TODO (justinfagnani): Create a benchmark of Map.has() + Map.set(\n    // vs just Map.set()\n    if (!this._$changedProperties.has(name)) {\n      this._$changedProperties.set(name, oldValue);\n    }\n    // Add to reflecting properties set.\n    // Note, it's important that every change has a chance to add the\n    // property to `__reflectingProperties`. This ensures setting\n    // attribute + property reflects correctly.\n    if (options.reflect === true && this.__reflectingProperty !== name) {\n      (this.__reflectingProperties ??= new Set()).add(name);\n    }\n  }\n  /**\n   * Sets up the element to asynchronously update.\n   */\n  __enqueueUpdate() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.isUpdatePending = true;\n      try {\n        // Ensure any previous update has resolved before updating.\n        // This `await` also ensures that property changes are batched.\n        yield _this.__updatePromise;\n      } catch (e) {\n        // Refire any previous errors async so they do not disrupt the update\n        // cycle. Errors are refired so developers have a chance to observe\n        // them, and this can be done by implementing\n        // `window.onunhandledrejection`.\n        Promise.reject(e);\n      }\n      const result = _this.scheduleUpdate();\n      // If `scheduleUpdate` returns a Promise, we await it. This is done to\n      // enable coordinating updates with a scheduler. Note, the result is\n      // checked to avoid delaying an additional microtask unless we need to.\n      if (result != null) {\n        yield result;\n      }\n      return !_this.isUpdatePending;\n    })();\n  }\n  /**\n   * Schedules an element update. You can override this method to change the\n   * timing of updates by returning a Promise. The update will await the\n   * returned Promise, and you should resolve the Promise to allow the update\n   * to proceed. If this method is overridden, `super.scheduleUpdate()`\n   * must be called.\n   *\n   * For instance, to schedule updates to occur just before the next frame:\n   *\n   * ```ts\n   * override protected async scheduleUpdate(): Promise<unknown> {\n   *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n   *   super.scheduleUpdate();\n   * }\n   * ```\n   * @category updates\n   */\n  scheduleUpdate() {\n    const result = this.performUpdate();\n    if (DEV_MODE && this.constructor.enabledWarnings.includes('async-perform-update') && typeof result?.then === 'function') {\n      issueWarning('async-perform-update', `Element ${this.localName} returned a Promise from performUpdate(). ` + `This behavior is deprecated and will be removed in a future ` + `version of ReactiveElement.`);\n    }\n    return result;\n  }\n  /**\n   * Performs an element update. Note, if an exception is thrown during the\n   * update, `firstUpdated` and `updated` will not be called.\n   *\n   * Call `performUpdate()` to immediately process a pending update. This should\n   * generally not be needed, but it can be done in rare cases when you need to\n   * update synchronously.\n   *\n   * @category updates\n   */\n  performUpdate() {\n    // Abort any update if one is not pending when this is called.\n    // This can happen if `performUpdate` is called early to \"flush\"\n    // the update.\n    if (!this.isUpdatePending) {\n      return;\n    }\n    debugLogEvent?.({\n      kind: 'update'\n    });\n    if (!this.hasUpdated) {\n      // Create renderRoot before first update. This occurs in `connectedCallback`\n      // but is done here to support out of tree calls to `enableUpdating`/`performUpdate`.\n      this.renderRoot ??= this.createRenderRoot();\n      if (DEV_MODE) {\n        // Produce warning if any reactive properties on the prototype are\n        // shadowed by class fields. Instance fields set before upgrade are\n        // deleted by this point, so any own property is caused by class field\n        // initialization in the constructor.\n        const ctor = this.constructor;\n        const shadowedProperties = [...ctor.elementProperties.keys()].filter(p => this.hasOwnProperty(p) && p in getPrototypeOf(this));\n        if (shadowedProperties.length) {\n          throw new Error(`The following properties on element ${this.localName} will not ` + `trigger updates as expected because they are set using class ` + `fields: ${shadowedProperties.join(', ')}. ` + `Native class fields and some compiled output will overwrite ` + `accessors used for detecting changes. See ` + `https://lit.dev/msg/class-field-shadowing ` + `for more information.`);\n        }\n      }\n      // Mixin instance properties once, if they exist.\n      if (this.__instanceProperties) {\n        // TODO (justinfagnani): should we use the stored value? Could a new value\n        // have been set since we stored the own property value?\n        for (const [p, value] of this.__instanceProperties) {\n          this[p] = value;\n        }\n        this.__instanceProperties = undefined;\n      }\n      // Trigger initial value reflection and populate the initial\n      // changedProperties map, but only for the case of experimental\n      // decorators on accessors, which will not have already populated the\n      // changedProperties map. We can't know if these accessors had\n      // initializers, so we just set them anyway - a difference from\n      // experimental decorators on fields and standard decorators on\n      // auto-accessors.\n      // For context why experimentalDecorators with auto accessors are handled\n      // specifically also see:\n      // https://github.com/lit/lit/pull/4183#issuecomment-1711959635\n      const elementProperties = this.constructor.elementProperties;\n      if (elementProperties.size > 0) {\n        for (const [p, options] of elementProperties) {\n          if (options.wrapped === true && !this._$changedProperties.has(p) && this[p] !== undefined) {\n            this._$changeProperty(p, this[p], options);\n          }\n        }\n      }\n    }\n    let shouldUpdate = false;\n    const changedProperties = this._$changedProperties;\n    try {\n      shouldUpdate = this.shouldUpdate(changedProperties);\n      if (shouldUpdate) {\n        this.willUpdate(changedProperties);\n        this.__controllers?.forEach(c => c.hostUpdate?.());\n        this.update(changedProperties);\n      } else {\n        this.__markUpdated();\n      }\n    } catch (e) {\n      // Prevent `firstUpdated` and `updated` from running when there's an\n      // update exception.\n      shouldUpdate = false;\n      // Ensure element can accept additional updates after an exception.\n      this.__markUpdated();\n      throw e;\n    }\n    // The update is no longer considered pending and further updates are now allowed.\n    if (shouldUpdate) {\n      this._$didUpdate(changedProperties);\n    }\n  }\n  /**\n   * Invoked before `update()` to compute values needed during the update.\n   *\n   * Implement `willUpdate` to compute property values that depend on other\n   * properties and are used in the rest of the update process.\n   *\n   * ```ts\n   * willUpdate(changedProperties) {\n   *   // only need to check changed properties for an expensive computation.\n   *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {\n   *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);\n   *   }\n   * }\n   *\n   * render() {\n   *   return html`SHA: ${this.sha}`;\n   * }\n   * ```\n   *\n   * @category updates\n   */\n  willUpdate(_changedProperties) {}\n  // Note, this is an override point for polyfill-support.\n  // @internal\n  _$didUpdate(changedProperties) {\n    this.__controllers?.forEach(c => c.hostUpdated?.());\n    if (!this.hasUpdated) {\n      this.hasUpdated = true;\n      this.firstUpdated(changedProperties);\n    }\n    this.updated(changedProperties);\n    if (DEV_MODE && this.isUpdatePending && this.constructor.enabledWarnings.includes('change-in-update')) {\n      issueWarning('change-in-update', `Element ${this.localName} scheduled an update ` + `(generally because a property was set) ` + `after an update completed, causing a new update to be scheduled. ` + `This is inefficient and should be avoided unless the next update ` + `can only be scheduled as a side effect of the previous update.`);\n    }\n  }\n  __markUpdated() {\n    this._$changedProperties = new Map();\n    this.isUpdatePending = false;\n  }\n  /**\n   * Returns a Promise that resolves when the element has completed updating.\n   * The Promise value is a boolean that is `true` if the element completed the\n   * update without triggering another update. The Promise result is `false` if\n   * a property was set inside `updated()`. If the Promise is rejected, an\n   * exception was thrown during the update.\n   *\n   * To await additional asynchronous work, override the `getUpdateComplete`\n   * method. For example, it is sometimes useful to await a rendered element\n   * before fulfilling this Promise. To do this, first await\n   * `super.getUpdateComplete()`, then any subsequent state.\n   *\n   * @return A promise of a boolean that resolves to true if the update completed\n   *     without triggering another update.\n   * @category updates\n   */\n  get updateComplete() {\n    return this.getUpdateComplete();\n  }\n  /**\n   * Override point for the `updateComplete` promise.\n   *\n   * It is not safe to override the `updateComplete` getter directly due to a\n   * limitation in TypeScript which means it is not possible to call a\n   * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n   * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n   * This method should be overridden instead. For example:\n   *\n   * ```ts\n   * class MyElement extends LitElement {\n   *   override async getUpdateComplete() {\n   *     const result = await super.getUpdateComplete();\n   *     await this._myChild.updateComplete;\n   *     return result;\n   *   }\n   * }\n   * ```\n   *\n   * @return A promise of a boolean that resolves to true if the update completed\n   *     without triggering another update.\n   * @category updates\n   */\n  getUpdateComplete() {\n    return this.__updatePromise;\n  }\n  /**\n   * Controls whether or not `update()` should be called when the element requests\n   * an update. By default, this method always returns `true`, but this can be\n   * customized to control when to update.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  shouldUpdate(_changedProperties) {\n    return true;\n  }\n  /**\n   * Updates the element. This method reflects property values to attributes.\n   * It can be overridden to render and keep updated element DOM.\n   * Setting properties inside this method will *not* trigger\n   * another update.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  update(_changedProperties) {\n    // The forEach() expression will only run when when __reflectingProperties is\n    // defined, and it returns undefined, setting __reflectingProperties to\n    // undefined\n    this.__reflectingProperties &&= this.__reflectingProperties.forEach(p => this.__propertyToAttribute(p, this[p]));\n    this.__markUpdated();\n  }\n  /**\n   * Invoked whenever the element is updated. Implement to perform\n   * post-updating tasks via DOM APIs, for example, focusing an element.\n   *\n   * Setting properties inside this method will trigger the element to update\n   * again after this update cycle completes.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  updated(_changedProperties) {}\n  /**\n   * Invoked when the element is first updated. Implement to perform one time\n   * work on the element after update.\n   *\n   * ```ts\n   * firstUpdated() {\n   *   this.renderRoot.getElementById('my-text-area').focus();\n   * }\n   * ```\n   *\n   * Setting properties inside this method will trigger the element to update\n   * again after this update cycle completes.\n   *\n   * @param _changedProperties Map of changed properties with old values\n   * @category updates\n   */\n  firstUpdated(_changedProperties) {}\n}\n/**\n * Memoized list of all element styles.\n * Created lazily on user subclasses when finalizing the class.\n * @nocollapse\n * @category styles\n */\nReactiveElement.elementStyles = [];\n/**\n * Options used when calling `attachShadow`. Set this property to customize\n * the options for the shadowRoot; for example, to create a closed\n * shadowRoot: `{mode: 'closed'}`.\n *\n * Note, these options are used in `createRenderRoot`. If this method\n * is customized, options should be respected if possible.\n * @nocollapse\n * @category rendering\n */\nReactiveElement.shadowRootOptions = {\n  mode: 'open'\n};\n// Assigned here to work around a jscompiler bug with static fields\n// when compiling to ES5.\n// https://github.com/google/closure-compiler/issues/3177\nReactiveElement[JSCompiler_renameProperty('elementProperties', ReactiveElement)] = new Map();\nReactiveElement[JSCompiler_renameProperty('finalized', ReactiveElement)] = new Map();\n// Apply polyfills if available\npolyfillSupport?.({\n  ReactiveElement\n});\n// Dev mode warnings...\nif (DEV_MODE) {\n  // Default warning set.\n  ReactiveElement.enabledWarnings = ['change-in-update', 'async-perform-update'];\n  const ensureOwnWarnings = function (ctor) {\n    if (!ctor.hasOwnProperty(JSCompiler_renameProperty('enabledWarnings', ctor))) {\n      ctor.enabledWarnings = ctor.enabledWarnings.slice();\n    }\n  };\n  ReactiveElement.enableWarning = function (warning) {\n    ensureOwnWarnings(this);\n    if (!this.enabledWarnings.includes(warning)) {\n      this.enabledWarnings.push(warning);\n    }\n  };\n  ReactiveElement.disableWarning = function (warning) {\n    ensureOwnWarnings(this);\n    const i = this.enabledWarnings.indexOf(warning);\n    if (i >= 0) {\n      this.enabledWarnings.splice(i, 1);\n    }\n  };\n}\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for ReactiveElement usage.\n(global.reactiveElementVersions ??= []).push('2.0.4');\nif (DEV_MODE && global.reactiveElementVersions.length > 1) {\n  issueWarning('multiple-versions', `Multiple versions of Lit loaded. Loading multiple versions ` + `is not recommended.`);\n}",
  "map": {
    "version": 3,
    "names": [
      "getCompatibleStyle",
      "adoptStyles",
      "is",
      "defineProperty",
      "getOwnPropertyDescriptor",
      "getOwnPropertyNames",
      "getOwnPropertySymbols",
      "getPrototypeOf",
      "Object",
      "NODE_MODE",
      "global",
      "globalThis",
      "customElements",
      "DEV_MODE",
      "issueWarning",
      "trustedTypes",
      "emptyStringForBooleanAttribute",
      "emptyScript",
      "polyfillSupport",
      "reactiveElementPolyfillSupportDevMode",
      "reactiveElementPolyfillSupport",
      "issuedWarnings",
      "litIssuedWarnings",
      "Set",
      "code",
      "warning",
      "has",
      "console",
      "warn",
      "add",
      "ShadyDOM",
      "inUse",
      "undefined",
      "debugLogEvent",
      "event",
      "shouldEmit",
      "emitLitDebugLogEvents",
      "dispatchEvent",
      "CustomEvent",
      "detail",
      "JSCompiler_renameProperty",
      "prop",
      "_obj",
      "defaultConverter",
      "toAttribute",
      "value",
      "type",
      "Boolean",
      "Array",
      "JSON",
      "stringify",
      "fromAttribute",
      "fromValue",
      "Number",
      "parse",
      "e",
      "notEqual",
      "old",
      "defaultPropertyDeclaration",
      "attribute",
      "String",
      "converter",
      "reflect",
      "hasChanged",
      "Symbol",
      "metadata",
      "litPropertyMetadata",
      "WeakMap",
      "ReactiveElement",
      "HTMLElement",
      "addInitializer",
      "initializer",
      "__prepare",
      "_initializers",
      "push",
      "observedAttributes",
      "finalize",
      "__attributeToPropertyMap",
      "keys",
      "createProperty",
      "name",
      "options",
      "state",
      "elementProperties",
      "set",
      "noAccessor",
      "key",
      "for",
      "descriptor",
      "getPropertyDescriptor",
      "prototype",
      "get",
      "v",
      "Error",
      "call",
      "oldValue",
      "requestUpdate",
      "configurable",
      "enumerable",
      "getPropertyOptions",
      "hasOwnProperty",
      "superCtor",
      "Map",
      "finalized",
      "props",
      "properties",
      "propKeys",
      "p",
      "attr",
      "__attributeNameForProperty",
      "elementStyles",
      "finalizeStyles",
      "styles",
      "isArray",
      "flat",
      "Infinity",
      "reverse",
      "s",
      "unshift",
      "toLowerCase",
      "constructor",
      "__instanceProperties",
      "isUpdatePending",
      "hasUpdated",
      "__reflectingProperty",
      "__initialize",
      "__updatePromise",
      "Promise",
      "res",
      "enableUpdating",
      "_$changedProperties",
      "__saveInstanceProperties",
      "forEach",
      "i",
      "addController",
      "controller",
      "__controllers",
      "renderRoot",
      "isConnected",
      "hostConnected",
      "removeController",
      "delete",
      "instanceProperties",
      "size",
      "createRenderRoot",
      "shadowRoot",
      "attachShadow",
      "shadowRootOptions",
      "connectedCallback",
      "c",
      "_requestedUpdate",
      "disconnectedCallback",
      "hostDisconnected",
      "attributeChangedCallback",
      "_old",
      "_$attributeToProperty",
      "__propertyToAttribute",
      "elemProperties",
      "attrValue",
      "enabledWarnings",
      "includes",
      "localName",
      "removeAttribute",
      "setAttribute",
      "ctor",
      "propName",
      "Event",
      "newValue",
      "_$changeProperty",
      "__enqueueUpdate",
      "__reflectingProperties",
      "reject",
      "result",
      "scheduleUpdate",
      "performUpdate",
      "then",
      "kind",
      "shadowedProperties",
      "filter",
      "length",
      "join",
      "wrapped",
      "shouldUpdate",
      "changedProperties",
      "willUpdate",
      "hostUpdate",
      "update",
      "__markUpdated",
      "_$didUpdate",
      "_changedProperties",
      "hostUpdated",
      "firstUpdated",
      "updated",
      "updateComplete",
      "getUpdateComplete",
      "mode",
      "ensureOwnWarnings",
      "slice",
      "enableWarning",
      "disableWarning",
      "indexOf",
      "splice",
      "reactiveElementVersions"
    ],
    "sources": [
      "/home/asplap2479/Documents/Learning/weather-application/WeatherApp/node_modules/@lit/reactive-element/development/reactive-element.js"
    ],
    "sourcesContent": [
      "/**\n * @license\n * Copyright 2017 Google LLC\n * SPDX-License-Identifier: BSD-3-Clause\n */\n/**\n * Use this module if you want to create your own base class extending\n * {@link ReactiveElement}.\n * @packageDocumentation\n */\nimport { getCompatibleStyle, adoptStyles, } from './css-tag.js';\n// In the Node build, this import will be injected by Rollup:\n// import {HTMLElement, customElements} from '@lit-labs/ssr-dom-shim';\nexport * from './css-tag.js';\n// TODO (justinfagnani): Add `hasOwn` here when we ship ES2022\nconst { is, defineProperty, getOwnPropertyDescriptor, getOwnPropertyNames, getOwnPropertySymbols, getPrototypeOf, } = Object;\nconst NODE_MODE = false;\n// Lets a minifier replace globalThis references with a minified name\nconst global = globalThis;\nif (NODE_MODE) {\n    global.customElements ??= customElements;\n}\nconst DEV_MODE = true;\nlet issueWarning;\nconst trustedTypes = global\n    .trustedTypes;\n// Temporary workaround for https://crbug.com/993268\n// Currently, any attribute starting with \"on\" is considered to be a\n// TrustedScript source. Such boolean attributes must be set to the equivalent\n// trusted emptyScript value.\nconst emptyStringForBooleanAttribute = trustedTypes\n    ? trustedTypes.emptyScript\n    : '';\nconst polyfillSupport = DEV_MODE\n    ? global.reactiveElementPolyfillSupportDevMode\n    : global.reactiveElementPolyfillSupport;\nif (DEV_MODE) {\n    // Ensure warnings are issued only 1x, even if multiple versions of Lit\n    // are loaded.\n    const issuedWarnings = (global.litIssuedWarnings ??=\n        new Set());\n    // Issue a warning, if we haven't already.\n    issueWarning = (code, warning) => {\n        warning += ` See https://lit.dev/msg/${code} for more information.`;\n        if (!issuedWarnings.has(warning)) {\n            console.warn(warning);\n            issuedWarnings.add(warning);\n        }\n    };\n    issueWarning('dev-mode', `Lit is in dev mode. Not recommended for production!`);\n    // Issue polyfill support warning.\n    if (global.ShadyDOM?.inUse && polyfillSupport === undefined) {\n        issueWarning('polyfill-support-missing', `Shadow DOM is being polyfilled via \\`ShadyDOM\\` but ` +\n            `the \\`polyfill-support\\` module has not been loaded.`);\n    }\n}\n/**\n * Useful for visualizing and logging insights into what the Lit template system is doing.\n *\n * Compiled out of prod mode builds.\n */\nconst debugLogEvent = DEV_MODE\n    ? (event) => {\n        const shouldEmit = global\n            .emitLitDebugLogEvents;\n        if (!shouldEmit) {\n            return;\n        }\n        global.dispatchEvent(new CustomEvent('lit-debug', {\n            detail: event,\n        }));\n    }\n    : undefined;\n/*\n * When using Closure Compiler, JSCompiler_renameProperty(property, object) is\n * replaced at compile time by the munged name for object[property]. We cannot\n * alias this function, so we have to use a small shim that has the same\n * behavior when not compiling.\n */\n/*@__INLINE__*/\nconst JSCompiler_renameProperty = (prop, _obj) => prop;\nexport const defaultConverter = {\n    toAttribute(value, type) {\n        switch (type) {\n            case Boolean:\n                value = value ? emptyStringForBooleanAttribute : null;\n                break;\n            case Object:\n            case Array:\n                // if the value is `null` or `undefined` pass this through\n                // to allow removing/no change behavior.\n                value = value == null ? value : JSON.stringify(value);\n                break;\n        }\n        return value;\n    },\n    fromAttribute(value, type) {\n        let fromValue = value;\n        switch (type) {\n            case Boolean:\n                fromValue = value !== null;\n                break;\n            case Number:\n                fromValue = value === null ? null : Number(value);\n                break;\n            case Object:\n            case Array:\n                // Do *not* generate exception when invalid JSON is set as elements\n                // don't normally complain on being mis-configured.\n                // TODO(sorvell): Do generate exception in *dev mode*.\n                try {\n                    // Assert to adhere to Bazel's \"must type assert JSON parse\" rule.\n                    fromValue = JSON.parse(value);\n                }\n                catch (e) {\n                    fromValue = null;\n                }\n                break;\n        }\n        return fromValue;\n    },\n};\n/**\n * Change function that returns true if `value` is different from `oldValue`.\n * This method is used as the default for a property's `hasChanged` function.\n */\nexport const notEqual = (value, old) => !is(value, old);\nconst defaultPropertyDeclaration = {\n    attribute: true,\n    type: String,\n    converter: defaultConverter,\n    reflect: false,\n    hasChanged: notEqual,\n};\n// Ensure metadata is enabled. TypeScript does not polyfill\n// Symbol.metadata, so we must ensure that it exists.\nSymbol.metadata ??= Symbol('metadata');\n// Map from a class's metadata object to property options\n// Note that we must use nullish-coalescing assignment so that we only use one\n// map even if we load multiple version of this module.\nglobal.litPropertyMetadata ??= new WeakMap();\n/**\n * Base element class which manages element properties and attributes. When\n * properties change, the `update` method is asynchronously called. This method\n * should be supplied by subclasses to render updates as desired.\n * @noInheritDoc\n */\nexport class ReactiveElement\n// In the Node build, this `extends` clause will be substituted with\n// `(globalThis.HTMLElement ?? HTMLElement)`.\n//\n// This way, we will first prefer any global `HTMLElement` polyfill that the\n// user has assigned, and then fall back to the `HTMLElement` shim which has\n// been imported (see note at the top of this file about how this import is\n// generated by Rollup). Note that the `HTMLElement` variable has been\n// shadowed by this import, so it no longer refers to the global.\n extends HTMLElement {\n    /**\n     * Adds an initializer function to the class that is called during instance\n     * construction.\n     *\n     * This is useful for code that runs against a `ReactiveElement`\n     * subclass, such as a decorator, that needs to do work for each\n     * instance, such as setting up a `ReactiveController`.\n     *\n     * ```ts\n     * const myDecorator = (target: typeof ReactiveElement, key: string) => {\n     *   target.addInitializer((instance: ReactiveElement) => {\n     *     // This is run during construction of the element\n     *     new MyController(instance);\n     *   });\n     * }\n     * ```\n     *\n     * Decorating a field will then cause each instance to run an initializer\n     * that adds a controller:\n     *\n     * ```ts\n     * class MyElement extends LitElement {\n     *   @myDecorator foo;\n     * }\n     * ```\n     *\n     * Initializers are stored per-constructor. Adding an initializer to a\n     * subclass does not add it to a superclass. Since initializers are run in\n     * constructors, initializers will run in order of the class hierarchy,\n     * starting with superclasses and progressing to the instance's class.\n     *\n     * @nocollapse\n     */\n    static addInitializer(initializer) {\n        this.__prepare();\n        (this._initializers ??= []).push(initializer);\n    }\n    /**\n     * Returns a list of attributes corresponding to the registered properties.\n     * @nocollapse\n     * @category attributes\n     */\n    static get observedAttributes() {\n        // Ensure we've created all properties\n        this.finalize();\n        // this.__attributeToPropertyMap is only undefined after finalize() in\n        // ReactiveElement itself. ReactiveElement.observedAttributes is only\n        // accessed with ReactiveElement as the receiver when a subclass or mixin\n        // calls super.observedAttributes\n        return (this.__attributeToPropertyMap && [...this.__attributeToPropertyMap.keys()]);\n    }\n    /**\n     * Creates a property accessor on the element prototype if one does not exist\n     * and stores a {@linkcode PropertyDeclaration} for the property with the\n     * given options. The property setter calls the property's `hasChanged`\n     * property option or uses a strict identity check to determine whether or not\n     * to request an update.\n     *\n     * This method may be overridden to customize properties; however,\n     * when doing so, it's important to call `super.createProperty` to ensure\n     * the property is setup correctly. This method calls\n     * `getPropertyDescriptor` internally to get a descriptor to install.\n     * To customize what properties do when they are get or set, override\n     * `getPropertyDescriptor`. To customize the options for a property,\n     * implement `createProperty` like this:\n     *\n     * ```ts\n     * static createProperty(name, options) {\n     *   options = Object.assign(options, {myOption: true});\n     *   super.createProperty(name, options);\n     * }\n     * ```\n     *\n     * @nocollapse\n     * @category properties\n     */\n    static createProperty(name, options = defaultPropertyDeclaration) {\n        // If this is a state property, force the attribute to false.\n        if (options.state) {\n            options.attribute = false;\n        }\n        this.__prepare();\n        this.elementProperties.set(name, options);\n        if (!options.noAccessor) {\n            const key = DEV_MODE\n                ? // Use Symbol.for in dev mode to make it easier to maintain state\n                    // when doing HMR.\n                    Symbol.for(`${String(name)} (@property() cache)`)\n                : Symbol();\n            const descriptor = this.getPropertyDescriptor(name, key, options);\n            if (descriptor !== undefined) {\n                defineProperty(this.prototype, name, descriptor);\n            }\n        }\n    }\n    /**\n     * Returns a property descriptor to be defined on the given named property.\n     * If no descriptor is returned, the property will not become an accessor.\n     * For example,\n     *\n     * ```ts\n     * class MyElement extends LitElement {\n     *   static getPropertyDescriptor(name, key, options) {\n     *     const defaultDescriptor =\n     *         super.getPropertyDescriptor(name, key, options);\n     *     const setter = defaultDescriptor.set;\n     *     return {\n     *       get: defaultDescriptor.get,\n     *       set(value) {\n     *         setter.call(this, value);\n     *         // custom action.\n     *       },\n     *       configurable: true,\n     *       enumerable: true\n     *     }\n     *   }\n     * }\n     * ```\n     *\n     * @nocollapse\n     * @category properties\n     */\n    static getPropertyDescriptor(name, key, options) {\n        const { get, set } = getOwnPropertyDescriptor(this.prototype, name) ?? {\n            get() {\n                return this[key];\n            },\n            set(v) {\n                this[key] = v;\n            },\n        };\n        if (DEV_MODE && get == null) {\n            if ('value' in (getOwnPropertyDescriptor(this.prototype, name) ?? {})) {\n                throw new Error(`Field ${JSON.stringify(String(name))} on ` +\n                    `${this.name} was declared as a reactive property ` +\n                    `but it's actually declared as a value on the prototype. ` +\n                    `Usually this is due to using @property or @state on a method.`);\n            }\n            issueWarning('reactive-property-without-getter', `Field ${JSON.stringify(String(name))} on ` +\n                `${this.name} was declared as a reactive property ` +\n                `but it does not have a getter. This will be an error in a ` +\n                `future version of Lit.`);\n        }\n        return {\n            get() {\n                return get?.call(this);\n            },\n            set(value) {\n                const oldValue = get?.call(this);\n                set.call(this, value);\n                this.requestUpdate(name, oldValue, options);\n            },\n            configurable: true,\n            enumerable: true,\n        };\n    }\n    /**\n     * Returns the property options associated with the given property.\n     * These options are defined with a `PropertyDeclaration` via the `properties`\n     * object or the `@property` decorator and are registered in\n     * `createProperty(...)`.\n     *\n     * Note, this method should be considered \"final\" and not overridden. To\n     * customize the options for a given property, override\n     * {@linkcode createProperty}.\n     *\n     * @nocollapse\n     * @final\n     * @category properties\n     */\n    static getPropertyOptions(name) {\n        return this.elementProperties.get(name) ?? defaultPropertyDeclaration;\n    }\n    /**\n     * Initializes static own properties of the class used in bookkeeping\n     * for element properties, initializers, etc.\n     *\n     * Can be called multiple times by code that needs to ensure these\n     * properties exist before using them.\n     *\n     * This method ensures the superclass is finalized so that inherited\n     * property metadata can be copied down.\n     * @nocollapse\n     */\n    static __prepare() {\n        if (this.hasOwnProperty(JSCompiler_renameProperty('elementProperties', this))) {\n            // Already prepared\n            return;\n        }\n        // Finalize any superclasses\n        const superCtor = getPrototypeOf(this);\n        superCtor.finalize();\n        // Create own set of initializers for this class if any exist on the\n        // superclass and copy them down. Note, for a small perf boost, avoid\n        // creating initializers unless needed.\n        if (superCtor._initializers !== undefined) {\n            this._initializers = [...superCtor._initializers];\n        }\n        // Initialize elementProperties from the superclass\n        this.elementProperties = new Map(superCtor.elementProperties);\n    }\n    /**\n     * Finishes setting up the class so that it's ready to be registered\n     * as a custom element and instantiated.\n     *\n     * This method is called by the ReactiveElement.observedAttributes getter.\n     * If you override the observedAttributes getter, you must either call\n     * super.observedAttributes to trigger finalization, or call finalize()\n     * yourself.\n     *\n     * @nocollapse\n     */\n    static finalize() {\n        if (this.hasOwnProperty(JSCompiler_renameProperty('finalized', this))) {\n            return;\n        }\n        this.finalized = true;\n        this.__prepare();\n        // Create properties from the static properties block:\n        if (this.hasOwnProperty(JSCompiler_renameProperty('properties', this))) {\n            const props = this.properties;\n            const propKeys = [\n                ...getOwnPropertyNames(props),\n                ...getOwnPropertySymbols(props),\n            ];\n            for (const p of propKeys) {\n                this.createProperty(p, props[p]);\n            }\n        }\n        // Create properties from standard decorator metadata:\n        const metadata = this[Symbol.metadata];\n        if (metadata !== null) {\n            const properties = litPropertyMetadata.get(metadata);\n            if (properties !== undefined) {\n                for (const [p, options] of properties) {\n                    this.elementProperties.set(p, options);\n                }\n            }\n        }\n        // Create the attribute-to-property map\n        this.__attributeToPropertyMap = new Map();\n        for (const [p, options] of this.elementProperties) {\n            const attr = this.__attributeNameForProperty(p, options);\n            if (attr !== undefined) {\n                this.__attributeToPropertyMap.set(attr, p);\n            }\n        }\n        this.elementStyles = this.finalizeStyles(this.styles);\n        if (DEV_MODE) {\n            if (this.hasOwnProperty('createProperty')) {\n                issueWarning('no-override-create-property', 'Overriding ReactiveElement.createProperty() is deprecated. ' +\n                    'The override will not be called with standard decorators');\n            }\n            if (this.hasOwnProperty('getPropertyDescriptor')) {\n                issueWarning('no-override-get-property-descriptor', 'Overriding ReactiveElement.getPropertyDescriptor() is deprecated. ' +\n                    'The override will not be called with standard decorators');\n            }\n        }\n    }\n    /**\n     * Takes the styles the user supplied via the `static styles` property and\n     * returns the array of styles to apply to the element.\n     * Override this method to integrate into a style management system.\n     *\n     * Styles are deduplicated preserving the _last_ instance in the list. This\n     * is a performance optimization to avoid duplicated styles that can occur\n     * especially when composing via subclassing. The last item is kept to try\n     * to preserve the cascade order with the assumption that it's most important\n     * that last added styles override previous styles.\n     *\n     * @nocollapse\n     * @category styles\n     */\n    static finalizeStyles(styles) {\n        const elementStyles = [];\n        if (Array.isArray(styles)) {\n            // Dedupe the flattened array in reverse order to preserve the last items.\n            // Casting to Array<unknown> works around TS error that\n            // appears to come from trying to flatten a type CSSResultArray.\n            const set = new Set(styles.flat(Infinity).reverse());\n            // Then preserve original order by adding the set items in reverse order.\n            for (const s of set) {\n                elementStyles.unshift(getCompatibleStyle(s));\n            }\n        }\n        else if (styles !== undefined) {\n            elementStyles.push(getCompatibleStyle(styles));\n        }\n        return elementStyles;\n    }\n    /**\n     * Returns the property name for the given attribute `name`.\n     * @nocollapse\n     */\n    static __attributeNameForProperty(name, options) {\n        const attribute = options.attribute;\n        return attribute === false\n            ? undefined\n            : typeof attribute === 'string'\n                ? attribute\n                : typeof name === 'string'\n                    ? name.toLowerCase()\n                    : undefined;\n    }\n    constructor() {\n        super();\n        this.__instanceProperties = undefined;\n        /**\n         * True if there is a pending update as a result of calling `requestUpdate()`.\n         * Should only be read.\n         * @category updates\n         */\n        this.isUpdatePending = false;\n        /**\n         * Is set to `true` after the first update. The element code cannot assume\n         * that `renderRoot` exists before the element `hasUpdated`.\n         * @category updates\n         */\n        this.hasUpdated = false;\n        /**\n         * Name of currently reflecting property\n         */\n        this.__reflectingProperty = null;\n        this.__initialize();\n    }\n    /**\n     * Internal only override point for customizing work done when elements\n     * are constructed.\n     */\n    __initialize() {\n        this.__updatePromise = new Promise((res) => (this.enableUpdating = res));\n        this._$changedProperties = new Map();\n        // This enqueues a microtask that ust run before the first update, so it\n        // must be called before requestUpdate()\n        this.__saveInstanceProperties();\n        // ensures first update will be caught by an early access of\n        // `updateComplete`\n        this.requestUpdate();\n        this.constructor._initializers?.forEach((i) => i(this));\n    }\n    /**\n     * Registers a `ReactiveController` to participate in the element's reactive\n     * update cycle. The element automatically calls into any registered\n     * controllers during its lifecycle callbacks.\n     *\n     * If the element is connected when `addController()` is called, the\n     * controller's `hostConnected()` callback will be immediately called.\n     * @category controllers\n     */\n    addController(controller) {\n        (this.__controllers ??= new Set()).add(controller);\n        // If a controller is added after the element has been connected,\n        // call hostConnected. Note, re-using existence of `renderRoot` here\n        // (which is set in connectedCallback) to avoid the need to track a\n        // first connected state.\n        if (this.renderRoot !== undefined && this.isConnected) {\n            controller.hostConnected?.();\n        }\n    }\n    /**\n     * Removes a `ReactiveController` from the element.\n     * @category controllers\n     */\n    removeController(controller) {\n        this.__controllers?.delete(controller);\n    }\n    /**\n     * Fixes any properties set on the instance before upgrade time.\n     * Otherwise these would shadow the accessor and break these properties.\n     * The properties are stored in a Map which is played back after the\n     * constructor runs. Note, on very old versions of Safari (<=9) or Chrome\n     * (<=41), properties created for native platform properties like (`id` or\n     * `name`) may not have default values set in the element constructor. On\n     * these browsers native properties appear on instances and therefore their\n     * default value will overwrite any element default (e.g. if the element sets\n     * this.id = 'id' in the constructor, the 'id' will become '' since this is\n     * the native platform default).\n     */\n    __saveInstanceProperties() {\n        const instanceProperties = new Map();\n        const elementProperties = this.constructor\n            .elementProperties;\n        for (const p of elementProperties.keys()) {\n            if (this.hasOwnProperty(p)) {\n                instanceProperties.set(p, this[p]);\n                delete this[p];\n            }\n        }\n        if (instanceProperties.size > 0) {\n            this.__instanceProperties = instanceProperties;\n        }\n    }\n    /**\n     * Returns the node into which the element should render and by default\n     * creates and returns an open shadowRoot. Implement to customize where the\n     * element's DOM is rendered. For example, to render into the element's\n     * childNodes, return `this`.\n     *\n     * @return Returns a node into which to render.\n     * @category rendering\n     */\n    createRenderRoot() {\n        const renderRoot = this.shadowRoot ??\n            this.attachShadow(this.constructor.shadowRootOptions);\n        adoptStyles(renderRoot, this.constructor.elementStyles);\n        return renderRoot;\n    }\n    /**\n     * On first connection, creates the element's renderRoot, sets up\n     * element styling, and enables updating.\n     * @category lifecycle\n     */\n    connectedCallback() {\n        // Create renderRoot before controllers `hostConnected`\n        this.renderRoot ??=\n            this.createRenderRoot();\n        this.enableUpdating(true);\n        this.__controllers?.forEach((c) => c.hostConnected?.());\n    }\n    /**\n     * Note, this method should be considered final and not overridden. It is\n     * overridden on the element instance with a function that triggers the first\n     * update.\n     * @category updates\n     */\n    enableUpdating(_requestedUpdate) { }\n    /**\n     * Allows for `super.disconnectedCallback()` in extensions while\n     * reserving the possibility of making non-breaking feature additions\n     * when disconnecting at some point in the future.\n     * @category lifecycle\n     */\n    disconnectedCallback() {\n        this.__controllers?.forEach((c) => c.hostDisconnected?.());\n    }\n    /**\n     * Synchronizes property values when attributes change.\n     *\n     * Specifically, when an attribute is set, the corresponding property is set.\n     * You should rarely need to implement this callback. If this method is\n     * overridden, `super.attributeChangedCallback(name, _old, value)` must be\n     * called.\n     *\n     * See [using the lifecycle callbacks](https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements#using_the_lifecycle_callbacks)\n     * on MDN for more information about the `attributeChangedCallback`.\n     * @category attributes\n     */\n    attributeChangedCallback(name, _old, value) {\n        this._$attributeToProperty(name, value);\n    }\n    __propertyToAttribute(name, value) {\n        const elemProperties = this.constructor.elementProperties;\n        const options = elemProperties.get(name);\n        const attr = this.constructor.__attributeNameForProperty(name, options);\n        if (attr !== undefined && options.reflect === true) {\n            const converter = options.converter?.toAttribute !==\n                undefined\n                ? options.converter\n                : defaultConverter;\n            const attrValue = converter.toAttribute(value, options.type);\n            if (DEV_MODE &&\n                this.constructor.enabledWarnings.includes('migration') &&\n                attrValue === undefined) {\n                issueWarning('undefined-attribute-value', `The attribute value for the ${name} property is ` +\n                    `undefined on element ${this.localName}. The attribute will be ` +\n                    `removed, but in the previous version of \\`ReactiveElement\\`, ` +\n                    `the attribute would not have changed.`);\n            }\n            // Track if the property is being reflected to avoid\n            // setting the property again via `attributeChangedCallback`. Note:\n            // 1. this takes advantage of the fact that the callback is synchronous.\n            // 2. will behave incorrectly if multiple attributes are in the reaction\n            // stack at time of calling. However, since we process attributes\n            // in `update` this should not be possible (or an extreme corner case\n            // that we'd like to discover).\n            // mark state reflecting\n            this.__reflectingProperty = name;\n            if (attrValue == null) {\n                this.removeAttribute(attr);\n            }\n            else {\n                this.setAttribute(attr, attrValue);\n            }\n            // mark state not reflecting\n            this.__reflectingProperty = null;\n        }\n    }\n    /** @internal */\n    _$attributeToProperty(name, value) {\n        const ctor = this.constructor;\n        // Note, hint this as an `AttributeMap` so closure clearly understands\n        // the type; it has issues with tracking types through statics\n        const propName = ctor.__attributeToPropertyMap.get(name);\n        // Use tracking info to avoid reflecting a property value to an attribute\n        // if it was just set because the attribute changed.\n        if (propName !== undefined && this.__reflectingProperty !== propName) {\n            const options = ctor.getPropertyOptions(propName);\n            const converter = typeof options.converter === 'function'\n                ? { fromAttribute: options.converter }\n                : options.converter?.fromAttribute !== undefined\n                    ? options.converter\n                    : defaultConverter;\n            // mark state reflecting\n            this.__reflectingProperty = propName;\n            this[propName] = converter.fromAttribute(value, options.type\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            );\n            // mark state not reflecting\n            this.__reflectingProperty = null;\n        }\n    }\n    /**\n     * Requests an update which is processed asynchronously. This should be called\n     * when an element should update based on some state not triggered by setting\n     * a reactive property. In this case, pass no arguments. It should also be\n     * called when manually implementing a property setter. In this case, pass the\n     * property `name` and `oldValue` to ensure that any configured property\n     * options are honored.\n     *\n     * @param name name of requesting property\n     * @param oldValue old value of requesting property\n     * @param options property options to use instead of the previously\n     *     configured options\n     * @category updates\n     */\n    requestUpdate(name, oldValue, options) {\n        // If we have a property key, perform property update steps.\n        if (name !== undefined) {\n            if (DEV_MODE && name instanceof Event) {\n                issueWarning(``, `The requestUpdate() method was called with an Event as the property name. This is probably a mistake caused by binding this.requestUpdate as an event listener. Instead bind a function that will call it with no arguments: () => this.requestUpdate()`);\n            }\n            options ??= this.constructor.getPropertyOptions(name);\n            const hasChanged = options.hasChanged ?? notEqual;\n            const newValue = this[name];\n            if (hasChanged(newValue, oldValue)) {\n                this._$changeProperty(name, oldValue, options);\n            }\n            else {\n                // Abort the request if the property should not be considered changed.\n                return;\n            }\n        }\n        if (this.isUpdatePending === false) {\n            this.__updatePromise = this.__enqueueUpdate();\n        }\n    }\n    /**\n     * @internal\n     */\n    _$changeProperty(name, oldValue, options) {\n        // TODO (justinfagnani): Create a benchmark of Map.has() + Map.set(\n        // vs just Map.set()\n        if (!this._$changedProperties.has(name)) {\n            this._$changedProperties.set(name, oldValue);\n        }\n        // Add to reflecting properties set.\n        // Note, it's important that every change has a chance to add the\n        // property to `__reflectingProperties`. This ensures setting\n        // attribute + property reflects correctly.\n        if (options.reflect === true && this.__reflectingProperty !== name) {\n            (this.__reflectingProperties ??= new Set()).add(name);\n        }\n    }\n    /**\n     * Sets up the element to asynchronously update.\n     */\n    async __enqueueUpdate() {\n        this.isUpdatePending = true;\n        try {\n            // Ensure any previous update has resolved before updating.\n            // This `await` also ensures that property changes are batched.\n            await this.__updatePromise;\n        }\n        catch (e) {\n            // Refire any previous errors async so they do not disrupt the update\n            // cycle. Errors are refired so developers have a chance to observe\n            // them, and this can be done by implementing\n            // `window.onunhandledrejection`.\n            Promise.reject(e);\n        }\n        const result = this.scheduleUpdate();\n        // If `scheduleUpdate` returns a Promise, we await it. This is done to\n        // enable coordinating updates with a scheduler. Note, the result is\n        // checked to avoid delaying an additional microtask unless we need to.\n        if (result != null) {\n            await result;\n        }\n        return !this.isUpdatePending;\n    }\n    /**\n     * Schedules an element update. You can override this method to change the\n     * timing of updates by returning a Promise. The update will await the\n     * returned Promise, and you should resolve the Promise to allow the update\n     * to proceed. If this method is overridden, `super.scheduleUpdate()`\n     * must be called.\n     *\n     * For instance, to schedule updates to occur just before the next frame:\n     *\n     * ```ts\n     * override protected async scheduleUpdate(): Promise<unknown> {\n     *   await new Promise((resolve) => requestAnimationFrame(() => resolve()));\n     *   super.scheduleUpdate();\n     * }\n     * ```\n     * @category updates\n     */\n    scheduleUpdate() {\n        const result = this.performUpdate();\n        if (DEV_MODE &&\n            this.constructor.enabledWarnings.includes('async-perform-update') &&\n            typeof result?.then ===\n                'function') {\n            issueWarning('async-perform-update', `Element ${this.localName} returned a Promise from performUpdate(). ` +\n                `This behavior is deprecated and will be removed in a future ` +\n                `version of ReactiveElement.`);\n        }\n        return result;\n    }\n    /**\n     * Performs an element update. Note, if an exception is thrown during the\n     * update, `firstUpdated` and `updated` will not be called.\n     *\n     * Call `performUpdate()` to immediately process a pending update. This should\n     * generally not be needed, but it can be done in rare cases when you need to\n     * update synchronously.\n     *\n     * @category updates\n     */\n    performUpdate() {\n        // Abort any update if one is not pending when this is called.\n        // This can happen if `performUpdate` is called early to \"flush\"\n        // the update.\n        if (!this.isUpdatePending) {\n            return;\n        }\n        debugLogEvent?.({ kind: 'update' });\n        if (!this.hasUpdated) {\n            // Create renderRoot before first update. This occurs in `connectedCallback`\n            // but is done here to support out of tree calls to `enableUpdating`/`performUpdate`.\n            this.renderRoot ??=\n                this.createRenderRoot();\n            if (DEV_MODE) {\n                // Produce warning if any reactive properties on the prototype are\n                // shadowed by class fields. Instance fields set before upgrade are\n                // deleted by this point, so any own property is caused by class field\n                // initialization in the constructor.\n                const ctor = this.constructor;\n                const shadowedProperties = [...ctor.elementProperties.keys()].filter((p) => this.hasOwnProperty(p) && p in getPrototypeOf(this));\n                if (shadowedProperties.length) {\n                    throw new Error(`The following properties on element ${this.localName} will not ` +\n                        `trigger updates as expected because they are set using class ` +\n                        `fields: ${shadowedProperties.join(', ')}. ` +\n                        `Native class fields and some compiled output will overwrite ` +\n                        `accessors used for detecting changes. See ` +\n                        `https://lit.dev/msg/class-field-shadowing ` +\n                        `for more information.`);\n                }\n            }\n            // Mixin instance properties once, if they exist.\n            if (this.__instanceProperties) {\n                // TODO (justinfagnani): should we use the stored value? Could a new value\n                // have been set since we stored the own property value?\n                for (const [p, value] of this.__instanceProperties) {\n                    this[p] = value;\n                }\n                this.__instanceProperties = undefined;\n            }\n            // Trigger initial value reflection and populate the initial\n            // changedProperties map, but only for the case of experimental\n            // decorators on accessors, which will not have already populated the\n            // changedProperties map. We can't know if these accessors had\n            // initializers, so we just set them anyway - a difference from\n            // experimental decorators on fields and standard decorators on\n            // auto-accessors.\n            // For context why experimentalDecorators with auto accessors are handled\n            // specifically also see:\n            // https://github.com/lit/lit/pull/4183#issuecomment-1711959635\n            const elementProperties = this.constructor\n                .elementProperties;\n            if (elementProperties.size > 0) {\n                for (const [p, options] of elementProperties) {\n                    if (options.wrapped === true &&\n                        !this._$changedProperties.has(p) &&\n                        this[p] !== undefined) {\n                        this._$changeProperty(p, this[p], options);\n                    }\n                }\n            }\n        }\n        let shouldUpdate = false;\n        const changedProperties = this._$changedProperties;\n        try {\n            shouldUpdate = this.shouldUpdate(changedProperties);\n            if (shouldUpdate) {\n                this.willUpdate(changedProperties);\n                this.__controllers?.forEach((c) => c.hostUpdate?.());\n                this.update(changedProperties);\n            }\n            else {\n                this.__markUpdated();\n            }\n        }\n        catch (e) {\n            // Prevent `firstUpdated` and `updated` from running when there's an\n            // update exception.\n            shouldUpdate = false;\n            // Ensure element can accept additional updates after an exception.\n            this.__markUpdated();\n            throw e;\n        }\n        // The update is no longer considered pending and further updates are now allowed.\n        if (shouldUpdate) {\n            this._$didUpdate(changedProperties);\n        }\n    }\n    /**\n     * Invoked before `update()` to compute values needed during the update.\n     *\n     * Implement `willUpdate` to compute property values that depend on other\n     * properties and are used in the rest of the update process.\n     *\n     * ```ts\n     * willUpdate(changedProperties) {\n     *   // only need to check changed properties for an expensive computation.\n     *   if (changedProperties.has('firstName') || changedProperties.has('lastName')) {\n     *     this.sha = computeSHA(`${this.firstName} ${this.lastName}`);\n     *   }\n     * }\n     *\n     * render() {\n     *   return html`SHA: ${this.sha}`;\n     * }\n     * ```\n     *\n     * @category updates\n     */\n    willUpdate(_changedProperties) { }\n    // Note, this is an override point for polyfill-support.\n    // @internal\n    _$didUpdate(changedProperties) {\n        this.__controllers?.forEach((c) => c.hostUpdated?.());\n        if (!this.hasUpdated) {\n            this.hasUpdated = true;\n            this.firstUpdated(changedProperties);\n        }\n        this.updated(changedProperties);\n        if (DEV_MODE &&\n            this.isUpdatePending &&\n            this.constructor.enabledWarnings.includes('change-in-update')) {\n            issueWarning('change-in-update', `Element ${this.localName} scheduled an update ` +\n                `(generally because a property was set) ` +\n                `after an update completed, causing a new update to be scheduled. ` +\n                `This is inefficient and should be avoided unless the next update ` +\n                `can only be scheduled as a side effect of the previous update.`);\n        }\n    }\n    __markUpdated() {\n        this._$changedProperties = new Map();\n        this.isUpdatePending = false;\n    }\n    /**\n     * Returns a Promise that resolves when the element has completed updating.\n     * The Promise value is a boolean that is `true` if the element completed the\n     * update without triggering another update. The Promise result is `false` if\n     * a property was set inside `updated()`. If the Promise is rejected, an\n     * exception was thrown during the update.\n     *\n     * To await additional asynchronous work, override the `getUpdateComplete`\n     * method. For example, it is sometimes useful to await a rendered element\n     * before fulfilling this Promise. To do this, first await\n     * `super.getUpdateComplete()`, then any subsequent state.\n     *\n     * @return A promise of a boolean that resolves to true if the update completed\n     *     without triggering another update.\n     * @category updates\n     */\n    get updateComplete() {\n        return this.getUpdateComplete();\n    }\n    /**\n     * Override point for the `updateComplete` promise.\n     *\n     * It is not safe to override the `updateComplete` getter directly due to a\n     * limitation in TypeScript which means it is not possible to call a\n     * superclass getter (e.g. `super.updateComplete.then(...)`) when the target\n     * language is ES5 (https://github.com/microsoft/TypeScript/issues/338).\n     * This method should be overridden instead. For example:\n     *\n     * ```ts\n     * class MyElement extends LitElement {\n     *   override async getUpdateComplete() {\n     *     const result = await super.getUpdateComplete();\n     *     await this._myChild.updateComplete;\n     *     return result;\n     *   }\n     * }\n     * ```\n     *\n     * @return A promise of a boolean that resolves to true if the update completed\n     *     without triggering another update.\n     * @category updates\n     */\n    getUpdateComplete() {\n        return this.__updatePromise;\n    }\n    /**\n     * Controls whether or not `update()` should be called when the element requests\n     * an update. By default, this method always returns `true`, but this can be\n     * customized to control when to update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    shouldUpdate(_changedProperties) {\n        return true;\n    }\n    /**\n     * Updates the element. This method reflects property values to attributes.\n     * It can be overridden to render and keep updated element DOM.\n     * Setting properties inside this method will *not* trigger\n     * another update.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    update(_changedProperties) {\n        // The forEach() expression will only run when when __reflectingProperties is\n        // defined, and it returns undefined, setting __reflectingProperties to\n        // undefined\n        this.__reflectingProperties &&= this.__reflectingProperties.forEach((p) => this.__propertyToAttribute(p, this[p]));\n        this.__markUpdated();\n    }\n    /**\n     * Invoked whenever the element is updated. Implement to perform\n     * post-updating tasks via DOM APIs, for example, focusing an element.\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    updated(_changedProperties) { }\n    /**\n     * Invoked when the element is first updated. Implement to perform one time\n     * work on the element after update.\n     *\n     * ```ts\n     * firstUpdated() {\n     *   this.renderRoot.getElementById('my-text-area').focus();\n     * }\n     * ```\n     *\n     * Setting properties inside this method will trigger the element to update\n     * again after this update cycle completes.\n     *\n     * @param _changedProperties Map of changed properties with old values\n     * @category updates\n     */\n    firstUpdated(_changedProperties) { }\n}\n/**\n * Memoized list of all element styles.\n * Created lazily on user subclasses when finalizing the class.\n * @nocollapse\n * @category styles\n */\nReactiveElement.elementStyles = [];\n/**\n * Options used when calling `attachShadow`. Set this property to customize\n * the options for the shadowRoot; for example, to create a closed\n * shadowRoot: `{mode: 'closed'}`.\n *\n * Note, these options are used in `createRenderRoot`. If this method\n * is customized, options should be respected if possible.\n * @nocollapse\n * @category rendering\n */\nReactiveElement.shadowRootOptions = { mode: 'open' };\n// Assigned here to work around a jscompiler bug with static fields\n// when compiling to ES5.\n// https://github.com/google/closure-compiler/issues/3177\nReactiveElement[JSCompiler_renameProperty('elementProperties', ReactiveElement)] = new Map();\nReactiveElement[JSCompiler_renameProperty('finalized', ReactiveElement)] = new Map();\n// Apply polyfills if available\npolyfillSupport?.({ ReactiveElement });\n// Dev mode warnings...\nif (DEV_MODE) {\n    // Default warning set.\n    ReactiveElement.enabledWarnings = [\n        'change-in-update',\n        'async-perform-update',\n    ];\n    const ensureOwnWarnings = function (ctor) {\n        if (!ctor.hasOwnProperty(JSCompiler_renameProperty('enabledWarnings', ctor))) {\n            ctor.enabledWarnings = ctor.enabledWarnings.slice();\n        }\n    };\n    ReactiveElement.enableWarning = function (warning) {\n        ensureOwnWarnings(this);\n        if (!this.enabledWarnings.includes(warning)) {\n            this.enabledWarnings.push(warning);\n        }\n    };\n    ReactiveElement.disableWarning = function (warning) {\n        ensureOwnWarnings(this);\n        const i = this.enabledWarnings.indexOf(warning);\n        if (i >= 0) {\n            this.enabledWarnings.splice(i, 1);\n        }\n    };\n}\n// IMPORTANT: do not change the property name or the assignment expression.\n// This line will be used in regexes to search for ReactiveElement usage.\n(global.reactiveElementVersions ??= []).push('2.0.4');\nif (DEV_MODE && global.reactiveElementVersions.length > 1) {\n    issueWarning('multiple-versions', `Multiple versions of Lit loaded. Loading multiple versions ` +\n        `is not recommended.`);\n}\n"
    ],
    "mappings": ";AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,kBAAkB,EAAEC,WAAW,QAAS,cAAc;AAC/D;AACA;AACA,cAAc,cAAc;AAC5B;AACA,MAAM;EAAEC,EAAE;EAAEC,cAAc;EAAEC,wBAAwB;EAAEC,mBAAmB;EAAEC,qBAAqB;EAAEC;AAAgB,CAAC,GAAGC,MAAM;AAC5H,MAAMC,SAAS,GAAG,KAAK;AACvB;AACA,MAAMC,MAAM,GAAGC,UAAU;AACzB,IAAIF,SAAS,EAAE;EACXC,MAAM,CAACE,cAAc,KAAKA,cAAc;AAC5C;AACA,MAAMC,QAAQ,GAAG,IAAI;AACrB,IAAIC,YAAY;AAChB,MAAMC,YAAY,GAAGL,MAAM,CACtBK,YAAY;AACjB;AACA;AACA;AACA;AACA,MAAMC,8BAA8B,GAAGD,YAAY,GAC7CA,YAAY,CAACE,WAAW,GACxB,EAAE;AACR,MAAMC,eAAe,GAAGL,QAAQ,GAC1BH,MAAM,CAACS,qCAAqC,GAC5CT,MAAM,CAACU,8BAA8B;AAC3C,IAAIP,QAAQ,EAAE;EACV;EACA;EACA,MAAMQ,cAAc,GAAIX,MAAM,CAACY,iBAAiB,KAC5C,IAAIC,GAAG,EAAG;EACd;EACAT,YAAY,GAAG,CAACU,IAAI,EAAEC,OAAO,KAAK;IAC9BA,OAAO,IAAK,4BAA2BD,IAAK,wBAAuB;IACnE,IAAI,CAACH,cAAc,CAACK,GAAG,CAACD,OAAO,CAAC,EAAE;MAC9BE,OAAO,CAACC,IAAI,CAACH,OAAO,CAAC;MACrBJ,cAAc,CAACQ,GAAG,CAACJ,OAAO,CAAC;IAC/B;EACJ,CAAC;EACDX,YAAY,CAAC,UAAU,EAAG,qDAAoD,CAAC;EAC/E;EACA,IAAIJ,MAAM,CAACoB,QAAQ,EAAEC,KAAK,IAAIb,eAAe,KAAKc,SAAS,EAAE;IACzDlB,YAAY,CAAC,0BAA0B,EAAG,sDAAqD,GAC1F,sDAAqD,CAAC;EAC/D;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,MAAMmB,aAAa,GAAGpB,QAAQ,GACvBqB,KAAK,IAAK;EACT,MAAMC,UAAU,GAAGzB,MAAM,CACpB0B,qBAAqB;EAC1B,IAAI,CAACD,UAAU,EAAE;IACb;EACJ;EACAzB,MAAM,CAAC2B,aAAa,CAAC,IAAIC,WAAW,CAAC,WAAW,EAAE;IAC9CC,MAAM,EAAEL;EACZ,CAAC,CAAC,CAAC;AACP,CAAC,GACCF,SAAS;AACf;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAMQ,yBAAyB,GAAG,CAACC,IAAI,EAAEC,IAAI,KAAKD,IAAI;AACtD,OAAO,MAAME,gBAAgB,GAAG;EAC5BC,WAAW,CAACC,KAAK,EAAEC,IAAI,EAAE;IACrB,QAAQA,IAAI;MACR,KAAKC,OAAO;QACRF,KAAK,GAAGA,KAAK,GAAG7B,8BAA8B,GAAG,IAAI;QACrD;MACJ,KAAKR,MAAM;MACX,KAAKwC,KAAK;QACN;QACA;QACAH,KAAK,GAAGA,KAAK,IAAI,IAAI,GAAGA,KAAK,GAAGI,IAAI,CAACC,SAAS,CAACL,KAAK,CAAC;QACrD;IAAM;IAEd,OAAOA,KAAK;EAChB,CAAC;EACDM,aAAa,CAACN,KAAK,EAAEC,IAAI,EAAE;IACvB,IAAIM,SAAS,GAAGP,KAAK;IACrB,QAAQC,IAAI;MACR,KAAKC,OAAO;QACRK,SAAS,GAAGP,KAAK,KAAK,IAAI;QAC1B;MACJ,KAAKQ,MAAM;QACPD,SAAS,GAAGP,KAAK,KAAK,IAAI,GAAG,IAAI,GAAGQ,MAAM,CAACR,KAAK,CAAC;QACjD;MACJ,KAAKrC,MAAM;MACX,KAAKwC,KAAK;QACN;QACA;QACA;QACA,IAAI;UACA;UACAI,SAAS,GAAGH,IAAI,CAACK,KAAK,CAACT,KAAK,CAAC;QACjC,CAAC,CACD,OAAOU,CAAC,EAAE;UACNH,SAAS,GAAG,IAAI;QACpB;QACA;IAAM;IAEd,OAAOA,SAAS;EACpB;AACJ,CAAC;AACD;AACA;AACA;AACA;AACA,OAAO,MAAMI,QAAQ,GAAG,CAACX,KAAK,EAAEY,GAAG,KAAK,CAACvD,EAAE,CAAC2C,KAAK,EAAEY,GAAG,CAAC;AACvD,MAAMC,0BAA0B,GAAG;EAC/BC,SAAS,EAAE,IAAI;EACfb,IAAI,EAAEc,MAAM;EACZC,SAAS,EAAElB,gBAAgB;EAC3BmB,OAAO,EAAE,KAAK;EACdC,UAAU,EAAEP;AAChB,CAAC;AACD;AACA;AACAQ,MAAM,CAACC,QAAQ,KAAKD,MAAM,CAAC,UAAU,CAAC;AACtC;AACA;AACA;AACAtD,MAAM,CAACwD,mBAAmB,KAAK,IAAIC,OAAO,EAAE;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA,QACSC,WAAW,CAAC;EACjB;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOC,cAAc,CAACC,WAAW,EAAE;IAC/B,IAAI,CAACC,SAAS,EAAE;IAChB,CAAC,IAAI,CAACC,aAAa,KAAK,EAAE,EAAEC,IAAI,CAACH,WAAW,CAAC;EACjD;EACA;AACJ;AACA;AACA;AACA;EACI,WAAWI,kBAAkB,GAAG;IAC5B;IACA,IAAI,CAACC,QAAQ,EAAE;IACf;IACA;IACA;IACA;IACA,OAAQ,IAAI,CAACC,wBAAwB,IAAI,CAAC,GAAG,IAAI,CAACA,wBAAwB,CAACC,IAAI,EAAE,CAAC;EACtF;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACI,OAAOC,cAAc,CAACC,IAAI,EAAEC,OAAO,GAAGvB,0BAA0B,EAAE;IAC9D;IACA,IAAIuB,OAAO,CAACC,KAAK,EAAE;MACfD,OAAO,CAACtB,SAAS,GAAG,KAAK;IAC7B;IACA,IAAI,CAACa,SAAS,EAAE;IAChB,IAAI,CAACW,iBAAiB,CAACC,GAAG,CAACJ,IAAI,EAAEC,OAAO,CAAC;IACzC,IAAI,CAACA,OAAO,CAACI,UAAU,EAAE;MACrB,MAAMC,GAAG,GAAGzE,QAAQ;MACd;MACE;MAC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",
    "ignoreList": []
  },
  "metadata": {},
  "sourceType": "module",
  "externalDependencies": []
}
